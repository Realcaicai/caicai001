新开一个坑，填设计模式的

简单工厂模式
策略模式：定义了算法家族，分别封装起来，让它们之间互相转换，此模式让算法的变化，不会影响到使用算法的用户。
【comment 2020-06-27】感觉上工厂模式里的对象，有对象的行为（方法），然后策略模式是对这些行为的封装。

开放闭合原则：类，模块，函数等等，可以扩展，不可修改。

依赖倒转原则：
a.高层模块不应该依赖低层模块，两个都应该依赖抽象。
b.抽象不应该依赖细节，细节应该依赖抽象。

装饰模式：动态得给一个对象添加一些额外得职责，就增加功能而言，装饰模式比生成子类更加灵活。 <--vs-->在主类中增加新的字段，方
法和逻辑，会增加主类的复杂度

[comment 2020-06-27] see package decorator

代理模式：为其他对象提供一种代理以控制对这个对象的访问。

简单工厂模式的最大优点在于工厂类中包含类必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，
去除类于具体产品的依赖。

工厂方法模式，定义了一个用户创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
	工厂方法克服了简单工厂违背放开-封闭原则的缺点，又保持了封装对象创建过程的优点。
	
原型模式（prototype），用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
	一般在初始化的信息不发生变化的情况下，克隆是最好的办法，这既隐藏了对象创建的细节，又对性能是大大的提高。
	MemberwiseClone() - 如果字段是值类型的，则对该字段执行逐位复制，如果字段是引用类型的，则复制引用但不复制引用对象，
	所以，原始对象及其副本引用统一对象。（潜复制）

【comment 2020-07-04】子类中的重复代码应该上升至父类。

模板方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法到结构即可重定义
该算法的某些特定步骤。